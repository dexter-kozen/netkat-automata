\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,latexsym,amsmath,stmaryrd,dk,dkenv}
\usepackage{tikz}
\usepgflibrary{shapes}
\usetikzlibrary{arrows,automata,backgrounds}
\usepackage{bbm}

\usepackage[all]{xy}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{<5> <6> <7> <8> <9> <10> gen * mathb <10.95> mathb10 <12> <14.4> <17.28> <20.74> <24.88> mathb12}{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}
\DeclareMathSymbol\fsmash\mathbin{mathb}{"0C}

\newcommand\den[1]{\llbracket #1\rrbracket}
\newcommand\rsem[1]{[#1]}
\newcommand\lsem[1]{L\den{#1}}
\newcommand\cset[1]{\{#1\}}
\newcommand\Rel{\kw{Rel}}
\newcommand\KL{\kw{Kl}}
\newcommand\KLP{\ensuremath{\KL\,\PP}} 
\newcommand\lam[2]{\lambda{#1}\kern1pt.\kern1pt{#2}}
\newcommand\nf[1]{#1^{\mathrm{nf}}}
\newcommand\CA{\ensuremath{P}}
\newcommand\At{\ensuremath{\mathit{At}}}
\newcommand\cseq[2]{\pseq{\pseq{#1}\cdots}{#2}}
\renewcommand\smash{\mathrel{\diamond}}
\newcommand\ssum{\mathop{\textstyle\sum}}
\newcommand\sbigcup{\mathop{\textstyle\bigcup}}
\newcommand\pdup{\mathop{\mathsf{dup}}}
\newcommand\One{\mathbf{1}}
\newcommand\Two{\mathbf{2}}
\newcommand\Exp{\mathsf{Exp}}
\newcommand\bval[1]{[#1]}
\renewcommand\star{^{\textstyle *}}
\newcommand\id{\mathsf{id}}
\newcommand\NetHKC[2]{\texttt{NetKATEquiv}(#1,#2)}
\newcommand\pair[2]{\langle #1,#2\rangle}
\renewcommand\powerset[1]{2^{#1}}
\newcommand\JI{\At\cdot(P\cdot\pdup)\star\cdot P}
\newcommand\setJI{2^{\At\cdot P\cdot(\pdup\cdot P)^{\scriptstyle *}}}
\newcommand\funJI{(2^{\At \cdot P})^{(P\cdot\pdup)^{\scriptstyle *}}}
\newcommand\acc{\mathsf{Accept}}

\begin{document}

A \emph{packet} is a map $\alpha:\{\text{fields}\}\to\{\text{values}\}$. There are a fixed finite number of fields in a packet. Fields are denoted $f,g,\ldots$~. The value of the field $f$ in packet $\alpha$ is denoted $\alpha.f$.

Packets can be modified using a rebinding operator. The packet $\alpha\subst mf$ is obtained by rebinding field $f$ to value $m$ in $\alpha$. Formally,
\begin{align*}
\alpha\subst mf.g = \begin{cases}
\alpha.g & \text{if $f\neq g$ (that is, if $f$ and $g$ are different fields)}\\
m & \text{if $f=g$}.
\end{cases}
\end{align*}

Packets are in one-to-one correspondence with atoms (complete tests). The packet with values $\alpha.f=n_f$ corresponds to the atom (complete test) $\bigwedge_f f=n_f$. We can therefore identify packets with atoms. This allows us to interpret $\alpha$ as either an atom or its corresponding packet, depending on context.

A \emph{packet history} is a nonnull list of packets $\alpha_1::\cdots::\alpha_n$. The \emph{head packet} is $\alpha_1$. Packet histories are denoted $h$.

\subsection*{NFAs}

Apply the Kleene construction to get an NFA $M_e$ from a NetKAT expression $e$. Assume wlog that De Morgan has been applied to tests so that all negations are applied only to primitive tests. Thus edge labels are either assignments $f\leftarrow n$, primitive tests $f = m$ or their negations $f\neq m$, or $\pdup$. Call this alphabet $\Sigma$. We have a nondeterministic automaton $(Q,\tau,S,F)$ where:
\begin{itemize}
\item
$Q$ is a finite set of states
\item
$\tau\subs Q\times\Sigma\times Q$ is the transition relation
\item
$S\subs Q$ are the start states
\item
$F\subs Q$ are the accept states.
\end{itemize}

\subsection*{Transducer Semantics}

Can be viewed operationally or denotationally.

\subsubsection*{Operational View}

Start with a single nonempty packet history placed on a nondeterminstically chosen start state. Now suppose we have a packet history on a state $s$. If $s\in F$, we can nondeterministically decide to stop, in which case we include the current packet history in the output set. Otherwise, we can move along any nondeterministically chosen enabled edge out of $s$, modifying the packet history as determined by the label of the edge. Whether an edge is enabled depends on the label and the current head packet.
\begin{itemize}
\item
Assignment edges are always enabled. If the edge is an assignment edge $s\goesto{f\leftarrow m}{}t$ and the current packet history is $\alpha::h$, then we can move from $s$ to $t$, rebinding the field $f$ of the head packet to the value $m$. The new packet history is $\alpha\subst mf::h$.
\item
Dup edges are always enabled. If the edge is a dup edge $s\goesto{\pdup}{}t$ and the current packet history is
$\alpha::h$, then we can move from $s$ to $t$, duplicating the head packet. The new packet history is $\alpha::\alpha::h$.
\item
A test edge $s\goesto{f=m}{}t$ or $s\goesto{f\neq m}{}t$ is enabled if the test is true for the head packet of the current packet history. If the current packet history is $\alpha::h$, then the edge $s\goesto{f=m}{}t$ is enabled if $\alpha.f=m$ and $s\goesto{f\neq m}{}t$ is enabled if $\alpha.f\neq m$. If the edge is enabled, we can move along the edge to state $t$, but we do not alter the packet history.
\end{itemize}
Let $L(N_e)(h)$ denote the output set starting with input history $h$. This is the the set of packet histories that can ever be ``output'' (can ever occupy a final state) on input $h$. Then $L(M_e):H\to\powerset H$. Note that $L(M_e)(h)$ only depends on the head packet of $h$; thus if $\alpha$ is a single packet, then
\begin{align*}
L(M_e)(\alpha::h) = \set{x::h}{x\in L(M_e)(\alpha)},
\end{align*}
or in other words, $x::h\in L(M_e)(\alpha::h)$ if and only if $x\in L(M_e)(\alpha)$.

\subsubsection*{Denotational View}

We can represent the output set of $L(M_e)(h)$ in terms of a least fixpoint of a monotone map on state labelings of type $\ell:Q\to\powerset H$, ordered by pointwise set inclusion; that is, $\ell\leq\ell'$ if $\ell(s)\subs\ell'(s)$ for all $s\in Q$. The labeling we are interested in is the least labeling $\ell:Q\to\powerset H$ such that:
\begin{itemize}
\item
$h\in \ell(s)$ for all $s\in S$
\item
if $\alpha::h \in \ell(s)$ and $s\goesto{f\leftarrow m}{}t\in\tau$, then $\alpha\subst mf::h \in \ell(t)$
\item
if $\alpha::h \in \ell(s)$ and $s\goesto{\pdup}{}t\in\tau$, then $\alpha::\alpha::h \in \ell(t)$
\item
if $\alpha::h \in \ell(s)$, $s\goesto{f=m}{}t\in\tau$, and $\alpha.f=m$, then $\alpha::h \in \ell(t)$
\item
if $\alpha::h \in \ell(s)$, $s\goesto{f\neq m}{}t\in\tau$, and $\alpha.f\neq m$, then $\alpha::h \in \ell(t)$.
\end{itemize}
Then $L(M_e)(h) = \bigcup_{t\in F}\ell(t)$.

\begin{theorem}
$\den e = L(M_e)$.
\end{theorem}

\subsection*{Language Recognition Semantics for NFAs}

Inputs to the automaton are strings in $\At\cdot(P\cdot\pdup)\star\cdot P$. Such a string $x$ is \emph{accepted} if there is a path from some $s\in S$ to some $t\in F$ with label $y$ such that the inequality $x\leq y$ follows from the axioms of NetKAT. The label of a directed path is the concatenation of the edge labels along the path in order. Let $G(M_e)$ denote the set of accepted strings.

We have overloaded the symbol $G$---recall that it also denotes the inductively defined map from NetKAT expressions to subsets of $\At\cdot(P\cdot\pdup)\star\cdot P$.

\begin{theorem}
$G(e) = G(M_e)$.
\end{theorem}

\subsection*{Relation between Transducer and Language Semantics}

Let $\alpha_i$ be packets, $1\leq i\leq m$. Let $p_i$ be the corresponding complete assignments; that is, if $\alpha_i.f = n_f$ for all fields $f$, then $p_i$ is the complete assignment that assigns $f\leftarrow n_f$ for all fields $f$.

\begin{theorem}
The following are equivalent:
\begin{enumerate}
\romanize
\item
$\alpha_m::\cdots::\alpha_1 \in L(M_e)(\alpha_0)$
\item
$\alpha_m::\cdots::\alpha_1 \in \den{e}(\alpha_0)$
\item
$\alpha_0 p_1 \pdup p_2 \pdup \cdots \pdup p_m \in G(M_e)$
\item
$\alpha_0 p_1 \pdup p_2 \pdup \cdots \pdup p_m \in G(e)$.
\end{enumerate}
\end{theorem}

\section*{DFAs}

\subsection*{Left-to-Right}

A left-to-right DFA is a coalgebra for the functor $FS = S^{\At\times P}\times 2^{\At\times P}$ with distinguished start state $s\in S$. The structure map is pair of functions
\begin{align*}
\delta &: S\to S^{\At\times P} & \eps &: S\to 2^{\At\times P}.
\end{align*}
We write $\delta_{\alpha p\pdup}(q)$ for $\delta(q)(\alpha,p)$ and $\eps_{\alpha p}(q)$ for $\eps(q)(\alpha,p)$, so
\begin{align*}
\delta_{\alpha p\pdup} &: S\to S & \eps_{\alpha p} &: S\to 2.
\end{align*}
Inputs to the automaton are strings of the form
\begin{align*}
\alpha p_1\pdup p_2\pdup\cdots\pdup p_m
\end{align*}
in $\At\cdot(P\cdot\pdup)\star\cdot P$. Acceptance is defined in terms of a coinductively defined predicate $\acc:S\times\At\cdot(P\cdot\pdup)\star\cdot P\to 2$.
\begin{align*}
\acc(q,\alpha p\pdup x) &= \acc(\delta_{\alpha p\pdup}(q),\alpha_p x)\\
\acc(q,\alpha p) &= \eps_{\alpha p}(q).
\end{align*}
A string $x\in\At\cdot(P\cdot\pdup)\star\cdot P$ is \emph{accepted} by the automaton if $\acc(s,x)$.

\subsection*{Right-to-Left}

A right-to-left DFA is a coalgebra for the functor $FS = S^{P}\times 2^{\At\times P}$ with distinguished start state $s\in S$. The structure map is a pair of functions
\begin{align*}
\delta &: S\to S^{P} & \eps &: S\to 2^{\At\times P}.
\end{align*}
We write $\delta_{\pdup p}(q)$ for $\delta(q)(p)$ and $\eps_{\alpha p}(q)$ for $\eps(q)(\alpha,p)$, so
\begin{align*}
\delta_{\pdup p} &: S\to S & \eps_{\alpha p} &: S\to 2.
\end{align*}
Inputs to the automaton are strings of the form
\begin{align*}
\alpha p_1\pdup p_2\pdup\cdots\pdup p_m
\end{align*}
in $\At\cdot P\cdot(\pdup\cdot P)\star$. Acceptance is defined in terms of a coinductively defined predicate $\acc:S\times\At\cdot P\cdot(\pdup\cdot P)\star\to 2$.
\begin{align*}
\acc(q,x\pdup p) &= \acc(\delta_{\pdup p}(q),x)\\
\acc(q,\alpha p) &= \eps_{\alpha p}(q).
\end{align*}
A string $x\in\At\cdot P\cdot(\pdup\cdot P)\star$ is \emph{accepted} by the automaton if $\acc(s,x)$.

\section*{Conversion of NetKAT Expressions to DFAs}

\subsection*{Antimirov Derivative}

\newcommand\cl[1]{\mathrm{cl}(#1)}

There is an analog of the set-theoretic derivative for KA \cite{} and KAT \cite{}
that applies to NetKAT. This is often called the \emph{Antimirov derivative} or
\emph{partial derivative}. This set-theoretic derivative can be used to show that
up to ACI, there are at most $2^n$ NetKAT derivatives accessible from $e$, where $n$ is the
number of subterms of $e$.
For NetKAT expression $e$, we define the \emph{closure} of $e$, denoted $\cl e$, to be the smallest setof terms containing $e$ and closed under the following rules:
\begin{equation}
\begin{array}{c@{\qquad}c@{\qquad}c}
\dfrac{e\in\cl{e_1}}{e\in\cl{e_1+e_2}} & \dfrac{e\in\cl{e_1}}{ee_2\in\cl{e_1e_2}} & \dfrac{e\in\cl{e_1}}{ee_1\star\in\cl{e_1\star}}\\[1em]\dfrac{e\in\cl{e_2}}{e\in\cl{e_1+e_2}} & \dfrac{e\in\cl{e_2}}{e\in\cl{e_1e_2}} & \dfrac{e\in\cl{b}}{e\in\cl{\bar b}}\end{array}
\label{eq:cldef}
\end{equation}
For $A$ a set of expressions, define $\cl A = \bigcup_{e\in A} \cl e$.

\begin{lemma}
The operator $\mathrm{cl}$ applied to sets is monotone; that is, if $A\subs B$, then $\cl A\subs\cl B$.
\end{lemma}
\begin{proof}
Obvious from the definition.
\end{proof}

\begin{lemma}
\label{eq:closure}
The operator $\mathrm{cl}$ is a closure operator; that is, $\cl{\cl e} = \cl e$.
\end{lemma}
\begin{proof}
Clearly $\cl e\subs\cl{\cl e}$. For the opposite inclusion,
it follows from the inductive definitions \eqref{eq:cldef} that
\begin{equation}
\begin{array}{r@{\ }lr@{\ }l}
\cl{e_1+e_2} &= \{e_1+e_2\} \cup \cl{e_1} \cup \cl{e_2} & \cl{e_1\star} &= \{e_1\star\} \cup \cl{e_1}e_1\star\\[1ex]
\cl{e_1e_2} &= \{e_1e_2\} \cup \cl{e_1}e_2 \cup \cl{e_2} & \cl{\bar b} &= \{\bar b\} \cup \cl{b}.
\end{array}
\label{eq:clprop}
\end{equation}
Proceeding by induction,
\begin{align*}
\cl{\cl{e_1+e_2}} &= \cl{\{e_1+e_2\} \cup \cl{e_1} \cup \cl{e_2}} = \cl{\{e_1+e_2\}} \cup \cl{\cl{e_1}} \cup \cl{\cl{e_2}}\\
&= \cl{e_1+e_2} \cup \cl{e_1} \cup \cl{e_2} = \cl{e_1+e_2}\\
\cl{\cl{e_1e_2}} &= \cl{\{e_1e_2\} \cup \cl{e_1}e_2 \cup \cl{e_2}} = \cl{\{e_1e_2\}} \cup \cl{\cl{e_1}e_2} \cup \cl{\cl{e_2}}\\
&= \cl{e_1e_2} \cup \cl{\cl{e_1}}e_2 \cup \cl{e_2} \cup \cl{e_2} = \cl{e_1e_2} \cup \cl{e_1}e_2 \cup \cl{e_2}\\
&= \cl{e_1e_2}\\
\cl{\cl{e_1\star}} &= \cl{\{e_1\star\} \cup \cl{e_1}e_1\star} = \cl{\{e_1\star\}} \cup \cl{\cl{e_1}}e_1\star \cup \cl{e_1\star}\\
&= \cl{e_1\star} \cup \cl{e_1}e_1\star \cup \cl{e_1\star} = \cl{e_1\star}\\
\cl{\cl{\bar b}} &= \cl{\{\bar b\} \cup \cl{b}} = \cl{\{\bar b\}} \cup \cl{\cl{b}} = \cl{\bar b} \cup \cl{b} = \cl{\bar b}.
\end{align*}
\end{proof}

\begin{lemma}
\label{eq:derivlinear}
The set $\cl e$ contains at most $\len e$ elements, where $\len e$ is thenumber of subterms of $e$.
\end{lemma}
\begin{proof}
Immediate from \eqref{eq:clprop}.
\end{proof}

Now we define an Antimirov derivative $(\Delta,E)$ for NetKAT and relate it to the syntactic Brzozowski derivative $(D,E)$. The Antimirov derivative is of type
\begin{align*}
\Delta_{\alpha p\pdup} &: \Exp\to\powerset\Exp & E_{\alpha p} &: \Exp\to 2.
\end{align*}
The component $E$ is the same as in the Brzozowski derivative. It will turn out that $\Delta_{\alpha p\pdup}(e)\subs\cl e$, which will give the desired bound of $2^n$.

\begin{align*}
\Delta_{\alpha p\pdup}(e_1+e_2) &= \Delta_{\alpha p\pdup}(e_1) \cup \Delta_{\alpha p\pdup}(e_2)\\
\Delta_{\alpha p\pdup}(e_1e_2) &= \Delta_{\alpha p\pdup}(e_1)e_2 \cup \bigcup_{E_{\alpha q}(e_1)=1}\Delta_{\alpha_q p\pdup}(e_2)\\
\Delta_{\alpha p\pdup}(e\star) &= \Delta_{\alpha p\pdup}(e)e\star \cup \bigcup_{E_{\alpha q}(e)=1}\Delta_{\alpha_q p\pdup}(e\star)\\
\Delta_{\alpha p\pdup}(b) &= 0.
\end{align*}

\begin{lemma}
\label{eq:Deltacl}
$\Delta_{\alpha p\pdup}(e) \subs \cl e$.
\end{lemma}

\begin{lemma}
\label{eq:DDelta}
$D_{\alpha p\pdup}(e) \equiv \ssum\Delta_{\alpha p\pdup}(e)$,
where $\equiv$ denotes equivalence modulo ACI, $(e_1+e_2)e = e_1e + e_2e$, $0e = 0$, and $1e = e$.
\end{lemma}

\end{document}
